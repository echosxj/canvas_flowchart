<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>canvas</title>

    <link rel="stylesheet" href="../public/canvas_css.css">

    <script src="../public/jquery-3.2.1.min.js"></script>
    <script>
        /* // 储存每个对象
         function Rect(x, y, text, color,width,height) {
         this.x = x;
         this.y = y;
         this.text={
         //是否会审
         shouldchecked:true,
         //审批人名单
         checkPersonList:['王一','李2','Jack']
         }
         this.color = color||'#e9f1f6';
         this.isSelected = false;
         this.width=width||230;
         this.height=height||150;
         this.mx=0;
         this.my=0;
         this.canStartLine = false;
         this.changeText = function (_text) {
         this.text=_text;
         }
         }

         function createRectObj(x, y, text, color,width,height) {
         return{
         x : x,
         y : y,
         text:{
         //是否会审
         shouldchecked:true,
         //审批人名单
         checkPersonList:['王一','李2','Jack']
         },
         color : color||'#e9f1f6',
         isSelected : false,
         width:width||230,
         height:height||150,
         mx:0,
         my:0,
         canStartLine : false,
         changeText : function(_text) {
         text=_text;
         }
         }
         }

         var Canvas_lists = [];
         var line_lists=[];
         var startRect_lists=[];
         var endRect_lists=[];
         var canvas;
         var context;

         //图中button属性
         var buttonName_lists=['删除左连接','删除右连接','修改信息'];
         var buttonGap = 5,buttonWidth=70,buttonHeight=30,buttonMarginTop=40;

         //关闭按钮
         var canvasCloseImg=new Image();
         canvasCloseImg.src='./close.png';
         var closeButtonWith=15,closeButtonMarginRight=20,closeButtonMarginTop=5;

         var cicleRadius = 10;
         //区别mouseup和click
         var moveFlag=false;
         var clickFlag=false;
         //判断是否可以画线
         var canLineDraw=false;
         //判断是否可以拖动
         var isDragging = false;

         window.onload = function() {
         canvas = document.getElementById("canvas");
         context = canvas.getContext("2d");


         canvas.onmousedown = function(e) {
         moveFlag = true;
         clickFlag = true;
         canvasClick(e);
         canvas.onmousemove = function (e) {
         clickFlag = false;
         if (isDragging == true) {
         dragRect(e);

         canvas.onmouseup = function () {
         console.log('drag stop');
         stopDragging();
         };
         }
         if (canLineDraw) {
         drawTmpLine(e);
         /!*var moveX = e.pageX - canvas.offsetLeft;
         var moveY = e.pageY - canvas.offsetTop;*!/
         canvas.onmouseup = function (e) {
         var isInLeftCicle=false;
         for (var i = 0; i < Canvas_lists.length; i++) {
         var rect = Canvas_lists[i];
         //判断左边圆圈
         var distanseLeftCicle = Math.sqrt(Math.pow(rect.x - cicleRadius - tmpPoint.x, 2)
         + Math.pow(rect.y + rect.height / 2 - tmpPoint.y, 2));
         if (distanseLeftCicle <= cicleRadius) {
         isInLeftCicle = true;
         (function (i) {
         if(endRect_lists.indexOf(i)==-1) {endRect = i;}
         })(i);
         }
         ;
         }
         ;

         if (isInLeftCicle) {
         if(startRect_lists.indexOf(startRect)==-1&&endRect_lists.indexOf(endRect)==-1&&startRect!=endRect&&startRect!=null&&endRect!=null){
         line_lists.push([startRect, endRect]);
         startRect_lists.push(startRect);
         endRect_lists.push(endRect);
         }

         }

         console.log('draw line stop');
         canLineDraw = false;
         startRect = null;
         endRect = null;
         tmpPoint = {x: null, y: null};
         drawAll();
         };
         }


         };
         //button点击事件
         canvas.onmouseup = function (e) {
         if(clickFlag) {
         console.log('click true');
         canvasClickButton(e);
         } else{console.log('clickfalse')}
         };
         };

         /!*  canvas.onmouseup = function () {
         stopDragging();
         canLineDraw=false;
         };*!/
         canvas.onmouseout = function () {
         stopDragging();
         //canLineDraw=false;
         };

         /!*canvas.onclick=function (e) {
         if(clickFlag) {
         console.log('click true');
         canvasClickButton(e);
         } else{console.log('clickfalse')}
         }*!/
         };

         function addRandomRect() {
         // 为圆圈计算一个随机大小和位置
         var x = randomFromTo(canvas.width/4, 3*canvas.width/4);
         var y = randomFromTo(canvas.height/4, 3*canvas.height/4);

         // 为圆圈计算一个随机颜色
         var colors = ["green", "blue", "red", "yellow", "magenta", "orange", "brown", "purple", "pink"];
         var color = colors[randomFromTo(0, 8)];

         // 创建一个新圆圈
         //var rect = new Rect(x, y, 'test');
         var rect = createRectObj(x, y, 'test');
         // 把它保存在数组中
         Canvas_lists.push(rect);

         // 重新绘制画布
         drawAll();
         }

         function clearCanvas() {
         Canvas_lists = [];
         line_lists = [];
         startRect_lists=[];
         startRect=null;
         endRect = null;
         drawAll();
         }

         function drawRects() {
         // 清除画布，准备绘制
         //context.clearRect(0, 0, canvas.width, canvas.height);

         // 遍历所有rect
         for(var i=0; i<Canvas_lists.length; i++) {
         var rect = Canvas_lists[i];
         context.save();
         context.beginPath();
         context.rect(rect.x, rect.y, rect.width, rect.height);

         //左边圈
         if(i>0){
         context.save();
         context.moveTo(rect.x, rect.y+rect.height/2);
         context.arc(rect.x-cicleRadius, rect.y+rect.height/2, cicleRadius, 0, Math.PI*2,true);
         context.restore();
         }

         //右边圈
         context.save();
         context.moveTo(rect.x+rect.width+2*cicleRadius, rect.y+rect.height/2);
         context.arc(rect.x+rect.width+cicleRadius, rect.y+rect.height/2, cicleRadius, 0, Math.PI*2);
         context.restore();

         //context.save();
         /!*context.translate(rect.x,rect.y);

         context.font='bold 20px Arial';
         context.textAlign='center';
         context.textBaseline='middle';
         context.fillStyle='blue';
         context.fillText('地球',100,100);
         context.fillText(rect.text,rect.x+100,rect.y+50);*!/
         //context.restore();

         context.fillStyle = rect.color;
         context.strokeStyle = "black";
         if (rect.isSelected) {
         context.lineWidth = 3;
         } else {
         context.lineWidth = 1;
         }
         context.fill();
         context.stroke();
         context.closePath();

         /!*填充text*!/
         context.save();
         context.translate(rect.x,rect.y);
         context.font='bold 10px Arial';
         //context.textAlign='center';
         //context.textBaseline='middle';
         context.fillStyle='black';
         var checkedInfo=rect.text.shouldchecked?'是':'否';
         context.fillText('是否会审：'+checkedInfo,20,20);
         var checkPersons=rect.text.checkPersonList.join(' , ');
         context.fillText('参评人员：'+checkPersons,20,40);


         /!*制作button*!/
         //button位置
         // button之间的间隔是5
         /!*var buttonName_lists=['删除上连接','删除下连接','修改信息'];
         var buttonGap = 5,buttonWidth=70,buttonHeight=30;*!/
         buttonName_lists.map(function (item,index) {
         context.save();
         context.beginPath();
         context.translate(buttonGap*(index+1)+buttonWidth*index,rect.height-buttonMarginTop);
         context.fillStyle='#21a675';
         context.rect(0,0,buttonWidth,buttonHeight);
         context.fill();
         context.closePath();
         //button字
         context.fillStyle='black';
         context.font='10px Arial';
         context.fillText(item,5,20);
         context.restore();
         });

         //画close按钮
         context.save();
         context.beginPath();
         //var closeButtonWith=15,closeButtonMarginRight=20,closeButtonMarginTop=5;
         context.drawImage(canvasCloseImg,rect.width-closeButtonMarginRight,closeButtonMarginTop,closeButtonWith,closeButtonWith);
         context.closePath();
         context.restore();


         context.restore();
         /!**!/
         context.restore();
         }
         }
         // line_lists = [[0,1],[2,3],[1,2]]
         function drawLine(){
         //draw from line_lists
         for(var i=0; i<line_lists.length; i++) {
         var line = line_lists[i];
         var rect1=Canvas_lists[line[0]];//右边圈
         var rect2=Canvas_lists[line[1]];//左边圈

         context.beginPath();
         context.save();
         context.moveTo(rect1.x+rect1.width+cicleRadius, rect1.y+rect1.height/2);
         context.lineTo(rect2.x-cicleRadius,rect2.y+rect2.height/2);
         context.restore();
         context.fillStyle = 'red';
         context.strokeStyle = "black";

         context.lineWidth = 3;
         context.fill();
         context.stroke();
         context.closePath();
         }
         //tmp
         if(startRect!=null&&tmpPoint.x&&tmpPoint.y){
         console.log('has tmpPoint');
         var _startRect =Canvas_lists[startRect];
         context.beginPath();
         context.moveTo(_startRect.x+_startRect.width+cicleRadius,_startRect.y+_startRect.height/2);
         context.lineTo(tmpPoint.x,tmpPoint.y);
         context.lineWidth=3;
         context.stroke();
         context.closePath();
         }

         }

         function drawAll(){
         context.clearRect(0, 0, canvas.width, canvas.height);
         drawRects();
         drawLine();
         }

         var previousSelectedRect;

         function canvasClick(e) {
         // 取得画布上被单击的点
         var clickX = e.pageX - canvas.offsetLeft;
         var clickY = e.pageY - canvas.offsetTop;
         //判断是否在矩形内，是=》矩形可拖拽
         for(var i=Canvas_lists.length-1; i>=0; i--) {
         var rect = Canvas_lists[i];
         //计算是否在该矩形内部
         var inRect = ((clickX-rect.x)>0)&&((clickX-rect.x)<rect.width)&&((clickY-rect.y)>0)&&((clickY-rect.y)<rect.height);
         if (inRect) {
         if (previousSelectedRect != null) {previousSelectedRect.isSelected = false;}
         rect.mx = clickX - rect.x;
         rect.my = clickY - rect.y;
         previousSelectedRect = rect;

         rect.isSelected = true;

         isDragging = true;

         drawAll();

         return;
         }
         }
         //判断是否在圆圈内，
         for(var i=Canvas_lists.length-1; i>=0; i--) {
         var rect = Canvas_lists[i];
         //判断左边圆圈
         var distanseLeftCicle = Math.sqrt(Math.pow(rect.x - cicleRadius - clickX, 2)
         + Math.pow(rect.y + rect.height/2 - clickY, 2));
         if(distanseLeftCicle<=cicleRadius){
         console.log('distanse left')
         };
         //判断右边边圆圈
         var distanseRightCicle = Math.sqrt(Math.pow(rect.x + rect.width + cicleRadius - clickX, 2)
         + Math.pow(rect.y + rect.height/2 - clickY, 2));
         if(distanseRightCicle<=cicleRadius){
         console.log('distanse right');
         canLineDraw = true;
         //目前先只支持右圆圈指向左圆圈
         // i值因为闭包需要匿名执行
         (function (i) {
         if(startRect_lists.indexOf(i)==-1){
         startRect = i;
         console.log('startRect',i);
         }
         })(i)
         }
         }
         }

         function canvasClickButton(e) {
         // 取得画布上被单击的点
         var clickX = e.pageX - canvas.offsetLeft;
         var clickY = e.pageY - canvas.offsetTop;
         //判断是否在矩形内，是=》矩形可拖拽
         for(var i=Canvas_lists.length-1; i>=0; i--) {
         var rect = Canvas_lists[i];
         //计算是否在该矩形内部
         var inRect = ((clickX-rect.x)>0)&&((clickX-rect.x)<rect.width)&&((clickY-rect.y)>0)&&((clickY-rect.y)<rect.height);
         if (inRect) {
         rect.isSelected = true;
         isDragging = false;
         //判断rect中的button
         //var buttonGap = 5,buttonWidth=70,buttonHeight=30;buttonMarginTop=50;
         for(var index=0;index<buttonName_lists.length;index++){
         var buttonX=buttonGap*(index+1)+buttonWidth*index+rect.x;
         var buttonY=rect.height-buttonMarginTop+rect.y;
         if(clickX>buttonX&&(clickX<(buttonX+buttonWidth))&&(clickY>buttonY)&&(clickY<(buttonY+buttonHeight))){
         console.log(i);//第几个rect
         console.log(index);//第i个rect的第index个button
         /!*console.log(buttonName_lists[index]);
         console.log(Canvas_lists[i].text);*!/
         switch (index){
         case 0: button1Click(i);return;break;
         case 1: button2Click(i);return;break;
         case 2: button3Click(i);return;break;
         default: break;
         }
         }
         }
         //判断close按钮
         //var closeButtonWith=15,closeButtonMarginRight=20,closeButtonMarginTop=5;
         var closeX=rect.x+rect.width-closeButtonMarginRight;
         var closeY=rect.y+closeButtonMarginTop;
         if((clickX-closeX)>=0&&(clickX-closeX)<=closeButtonWith&&(clickY-closeY)>=0&&(clickY-closeY)<=closeButtonWith){
         buttonCloseClick(i);
         }
         drawAll();
         return;
         }
         }

         }
         //buttonclick处理
         function button1Click(i){
         //删除i的左连接
         for(var index=0;index<line_lists.length;index++){
         var lines=line_lists[index];
         if(lines[1]==i){
         console.log('delete left line of Canvas_list-'+i);
         //删除line_lists
         line_lists.splice(index,1);
         //删除start和endRect_lists
         startRect_lists.splice(startRect_lists.indexOf(lines[0]),1);
         endRect_lists.splice(endRect_lists.indexOf(lines[1]),1);
         drawAll();
         return;
         }
         }
         }

         function button2Click(i) {
         //删除i的右连接
         for(var index=0;index<line_lists.length;index++){
         var lines=line_lists[index];
         if(lines[0]==i){
         console.log('delete right line of Canvas_list-'+i);
         //删除line_lists
         line_lists.splice(index,1);
         //删除start和endRect_lists
         startRect_lists.splice(startRect_lists.indexOf(lines[0]),1);
         endRect_lists.splice(endRect_lists.indexOf(lines[1]),1);
         drawAll();
         return;
         }
         }
         }

         function button3Click(i) {
         console.log(i);
         }

         function buttonCloseClick(i) {

         for(var indexLeft=0;indexLeft<line_lists.length;indexLeft++){
         var lines=line_lists[indexLeft];
         if(lines[1]==i){
         console.log('delete left line of Canvas_list-'+i);
         //删除line_lists
         line_lists.splice(indexLeft,1);
         //删除start和endRect_lists
         startRect_lists.splice(startRect_lists.indexOf(lines[0]),1);
         endRect_lists.splice(endRect_lists.indexOf(lines[1]),1);

         }
         }
         for(var indexRight=0;indexRight<line_lists.length;indexRight++){
         var lines=line_lists[indexRight];
         if(lines[0]==i){
         console.log('delete right line of Canvas_list-'+i);
         //删除line_lists
         line_lists.splice(indexRight,1);
         //删除start和endRect_lists
         startRect_lists.splice(startRect_lists.indexOf(lines[0]),1);
         endRect_lists.splice(endRect_lists.indexOf(lines[1]),1);
         }
         }
         Canvas_lists.splice(i,1);
         drawAll();
         }
         //连线
         var startRect;
         var endRect;
         var tmpPoint={x:null,y:null};

         function inRect(x,y){
         for(var i=Canvas_lists.length-1; i>=0; i--) {
         var rect = Canvas_lists[i];
         //计算是否在该矩形内部
         var inRect = ((clickX-rect.x)>0)&&((clickX-rect.x)<rect.width)&&((clickY-rect.y)>0)&&((clickY-rect.y)<rect.height);
         return inRect
         }
         }

         //在某个范围内生成随机数
         function randomFromTo(from, to) {
         return Math.floor(Math.random() * (to - from + 1) + from);
         }


         function stopDragging() {
         isDragging = false;
         }

         function dragRect(e) {
         // 判断是否开始拖拽
         if (isDragging == true) {
         // 判断拖拽对象是否存在
         if (previousSelectedRect != null) {
         // 取得鼠标位置
         var x = e.pageX - canvas.offsetLeft;
         var y = e.pageY - canvas.offsetTop;
         previousSelectedRect.x = x - previousSelectedRect.mx;
         previousSelectedRect.y = y - previousSelectedRect.my;

         // 更新画布
         drawAll();
         }
         }
         }
         //这个可以放到drwaLine里面 因为需要clearRect
         function drawTmpLine(e) {
         if(canLineDraw=true){
         var moveX = e.pageX - canvas.offsetLeft;
         var moveY = e.pageY - canvas.offsetTop;

         //判断是否在左边的圈里
         /!*   var isInLeftCicle = false;
         for(var i=0;i<Canvas_lists.length;i++){
         var rect = Canvas_lists[i];
         //判断左边圆圈
         var distanseLeftCicle = Math.sqrt(Math.pow(rect.x - cicleRadius - moveX, 2)
         + Math.pow(rect.y + rect.height/2 - moveY, 2));
         if(distanseLeftCicle<=cicleRadius){
         isInLeftCicle=true;
         (function (i) {
         endRect=i;
         })(i);
         };
         };

         if(isInLeftCicle){
         /!*canvas.onmouseup =function () {*!/
         line_lists.push([startRect,endRect]);
         /!*}*!/
         }else{*!/
         tmpPoint.x = moveX;
         tmpPoint.y = moveY;
         /!* }*!/



         drawAll()
         }
         }




         //画图外函数

         //输出canvas_lists
         function showCanvasData(id) {
         document.getElementById(id).innerText=Canvas_lists.toString();
         }*/
    </script>
</head>

<body>
<div></div>


<div id="test">
    <!--<div id="canvas_toolbar">
        <button id="canvas_btn_toggleDragRect" class="canvas_btn" onclick="toggleDragRect()">选择</button>
        <button id="canvas_btn_toggleDrawLine" class="canvas_btn" onclick="toggleDrawLine()">连线</button>
        <button id="canvas_btn_toggleDeleteLine" class="canvas_btn" onclick="toggleDeleteLine()">删除</button>
        <button class="canvas_btn" onclick="addRandomRect()">添加圆圈</button>
        <button class="canvas_btn" onclick="clearCanvas()">清空画布</button>
        <button class="canvas_btn" onclick="initCanvas(testList)">测试</button>
    </div>-->
    <div id="canvas_area">
        <canvas id="canvas_flowchart" class="canvas_style" width="800" height="500">
        </canvas>
    </div>
</div>
<textare id="showData">

</textare>


<div id="mask">
    <div id="canvas_input">
        <div>是否会审：
            <label><input type="radio" name='shouldChecked' value="true" checked>是</label>
            <label><input type="radio" name='shouldChecked' value="false">否</label>
        </div>
        <label>审评人：<input type="text" name="persons"></label>
        <button id="canvas_info_change" onclick="canvasInfoChange()">修改信息</button>
    </div>
</div>

<script src="canvas_flowchart.js"></script>

<script>
    var c=new CanvasFlowChart();
    c.init('test')
</script>
</body>
</html>